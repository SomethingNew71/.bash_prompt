# Sexy Bash Prompt, inspired by "Extravagant Zsh Prompt"
# Screenshot: http://img.gf3.ca/d54942f474256ec26a49893681c49b5a.png
# A big thanks to \amethyst on Freenode

if [[ $COLORTERM = gnome-* && $TERM = xterm ]]  && infocmp gnome-256color >/dev/null 2>&1; then export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then export TERM=xterm-256color
fi

if tput setaf 1 &> /dev/null; then
  tput sgr0
  if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
    # Coles Added Colors
    LIGHTBLUE=$(tput setaf 12)
    DARKBLUE=$(tput setaf 24)
    DARKRED=$(tput setaf 160)
    DARKESTRED=$(tput setaf 196)
    NICEWHITE=$(tput setaf 230)
    NICEYELLOW=$(tput setaf 226)
    YELLOW=$(tput setaf 136)
    NICEORANGE=$(tput setaf 130)
  else
    # I didn't find alternatives to my colors if your terminal doesnt support
    # 256 colors then upgrade your damn terminal
    MAGENTA=$(tput setaf 5)
    ORANGE=$(tput setaf 4)
    GREEN=$(tput setaf 2)
    PURPLE=$(tput setaf 1)
    WHITE=$(tput setaf 7)
  fi
  BOLD=$(tput bold)
  RESET=$(tput sgr0)
else
  # I didn't find alternatives to my colors if your terminal doesnt support
  # 256 colors then upgrade your damn terminal
  MAGENTA="\033[1;31m"
  ORANGE="\033[1;33m"
  GREEN="\033[1;32m"
  PURPLE="\033[1;35m"
  WHITE="\033[1;37m"
  BOLD=""
  RESET="\033[m"
fi

# Old Git Tracking system
# parse_git_dirty () {
#   [[ $(git status 2> /dev/null | tail -n1) == "nothing to commit, working directory clean" ]] && echo "*"
# }
# parse_git_branch () {
#   git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/"
# }

# New Git Tracking System
__powerline() {

    # Unicode symbols
    PS_SYMBOL_DARWIN='ï£¿'
    GIT_BRANCH_SYMBOL='â‘‚ '
    GIT_BRANCH_CHANGED_SYMBOL='+'
    GIT_NEED_PUSH_SYMBOL='â‡¡'
    GIT_NEED_PULL_SYMBOL='â‡£'
    PS_RED_CAR='ðŸš—'
    PS_POOP='ðŸ’©'

    DIM="\[$(tput dim)\]"
    REVERSE="\[$(tput rev)\]"
    RESET="\[$(tput sgr0)\]"
    BOLD="\[$(tput bold)\]"

    __git_info() {
      [ -x "$(which git)" ] || return    # git not found

      local git_eng="env LANG=C git"   # force git output in English to make our work easier
      # get current branch name or short SHA1 hash for detached head
      local branch="$($git_eng symbolic-ref --short HEAD 2>/dev/null || $git_eng describe --tags --always 2>/dev/null)"
      [ -n "$branch" ] || return  # git branch not found

      local marks

      # branch is modified?
      [ -n "$($git_eng status --porcelain)" ] && marks+=" $GIT_BRANCH_CHANGED_SYMBOL"

      # how many commits local branch is ahead/behind of remote?
      local stat="$($git_eng status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
      local aheadN="$(echo $stat | grep -o 'ahead [[:digit:]]\+' | grep -o '[[:digit:]]\+')"
      local behindN="$(echo $stat | grep -o 'behind [[:digit:]]\+' | grep -o '[[:digit:]]\+')"
      [ -n "$aheadN" ] && marks+=" $GIT_NEED_PUSH_SYMBOL$aheadN"
      [ -n "$behindN" ] && marks+=" $GIT_NEED_PULL_SYMBOL$behindN"

      # print the git branch segment without a trailing newline
      printf "$NICEWHITE$GIT_BRANCH_SYMBOL$DARKRED$branch$NICEYELLOW$marks"
    }

    ps1() {
      # Check the exit code of the previous command and display different
      # colors in the prompt accordingly.
      if [ $? -eq 0 ]; then
          local BG_EXIT="$BG_GREEN"
      else
          local BG_EXIT="$BG_RED"
      fi

      #this is what determine the actual output
      # Base PS1 prompt
      PS1="$PS_POOP \[$NICEWHITE\] - \[$NICEORANGE\]\cd  \[$NICEWHITE\]in \[$YELLOW\]\w "
      # Add Git Info to PS1 prompt
      PS1+="$(__git_info)"
      # Add New Line and end to PS1 prompt
      PS1+="\[$NICEWHITE\]\n$PS_SYMBOL_DARWIN\[$RESET\] "
    }

    PROMPT_COMMAND=ps1
}

__powerline
unset __powerline
